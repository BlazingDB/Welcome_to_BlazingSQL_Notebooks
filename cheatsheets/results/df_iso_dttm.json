{"num":{"0":39,"1":11,"2":31,"3":40,"4":33,"5":42,"6":36,"7":38,"8":17,"9":10},"float":{"0":6.88,"1":4.21,"2":4.71,"3":0.93,"4":9.26,"5":4.21,"6":3.01,"7":6.44,"8":5.28,"9":8.28},"datetime":{"0":"2020-10-08T12:12:01.000Z","1":null,"2":"2020-10-10T09:26:43.000Z","3":"2020-10-11T17:10:00.000Z","4":"2020-10-15T10:58:02.000Z","5":"2020-10-01T10:02:23.000Z","6":"2020-09-30T14:36:26.000Z","7":"2020-10-10T08:34:36.000Z","8":"2020-10-09T08:34:40.000Z","9":"2020-10-03T03:31:21.000Z"},"timedelta":{"0":"P0DT3H59M38S","1":null,"2":"P0DT3H35M9S","3":"P0DT2H54M26S","4":"P0DT9H52M38S","5":"P0DT5H41M20S","6":"P0DT6H46M49S","7":"P1DT1H2M51S","8":"P0DT8H28M52S","9":"P0DT6H32M32S"},"char":{"0":"C","1":"A","2":"U","3":"P","4":"O","5":"U","6":"T","7":"X","8":"P","9":"W"},"category":{"0":"D","1":"D","2":"D","3":"B","4":"D","5":"C","6":"D","7":"B","8":"D","9":"B"},"word":{"0":"data","1":"cuDF","2":"memory","3":"tabular","4":"parallel","5":"GPUs","6":null,"7":"csv","8":"dataframes","9":"python"},"string":{"0":"RAPIDS.ai is a suite of open-source libraries that allow you to run your end to end data science and analytics pipelines on GPUs.","1":"cuDF is a Python GPU DataFrame (built on the Apache Arrow columnar memory format)","2":"cuDF allows for loading, joining, aggregating, filtering, and otherwise manipulating tabular data using a DataFrame style API.","3":"If your workflow is fast enough on a single GPU or your data comfortably fits in memory on \n                 a single GPU, you would want to use cuDF.","4":"If you want to distribute your workflow across multiple GPUs or have more data than you can fit \n                 in memory on a single GPU you would want to use Dask-cuDF","5":"BlazingSQL provides a high-performance distributed SQL engine in Python","6":"BlazingSQL is built on the RAPIDS GPU data science ecosystem","7":"BlazingSQL lets you ETL raw data directly into GPU memory as a GPU DataFrame (GDF)","8":"Dask is a flexible library for parallel computing in Python","9":null}}